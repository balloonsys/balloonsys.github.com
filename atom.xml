<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Balloonsys Inc.]]></title>
  <link href="http://balloonsys.github.io/atom.xml" rel="self"/>
  <link href="http://balloonsys.github.io/"/>
  <updated>2014-03-11T19:55:24+08:00</updated>
  <id>http://balloonsys.github.io/</id>
  <author>
    <name><![CDATA[Linkou Bian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Flask设计RESTful API]]></title>
    <link href="http://balloonsys.github.io/blog/2014/03/11/design-restful-api-with-python-and-flask/"/>
    <updated>2014-03-11T19:12:58+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/03/11/design-restful-api-with-python-and-flask</id>
    <content type="html"><![CDATA[<p>Flask是一个Python WEB开发框架。在接下来的“西子快讯”APP开发过程中，我打算拿它来做RESTful API。虽然之前对Python并不了解，对Flask更是陌生，但爱折腾的本性促使我不断去学习。于是今天看blog、看文档，小有收获，略记一二。</p>

<!--more-->


<h2>准备工作</h2>

<p>确保机器上已经安装了Python、Pip、Virtualenv等工具。如果默认的Pip安装源比较慢，可以用v2ex的试试。具体方法是在~/.pip/下创建一个名为pip.conf的文件，输入新的pip源。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[global]
</span><span class='line'>index-url = http://pypi.v2ex.com/simple</span></code></pre></td></tr></table></div></figure>


<h2>安装Flask</h2>

<p>为了不影响系统的Python环境，我们用Virtualenv虚拟一个运行环境，然后在此环境下开发一个名为todo的小应用（纯RESTful API，JSON格式数据）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/Desktop
</span><span class='line'>mkdir todo-api
</span><span class='line'>cd todo-api
</span><span class='line'>virtualenv venv
</span><span class='line'>. venv/bin/activate</span></code></pre></td></tr></table></div></figure>


<p>此时命令行窗口应出现(venv)mbpr2013:todo-api linkoubian$ 这样的提示符，注意最左边的venv表明当前运行的是虚拟出来的环境。</p>

<p>这时执行pip install flask便可在venv下安装flask模块。</p>

<h2>测试Flask是否正常工作</h2>

<p>编写一个Hello World程序，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span><span class='line'>
</span><span class='line'><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
</span><span class='line'>  <span class="k">return</span> <span class="s">&quot;Hello, World!&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>  <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>保存为~/Desktop/todo-api/app.py，添加(chmod)可执行权限后，通过python app.py运行。此时打开浏览器，访问localhost:5000即可看到Hello, World!</p>

<h2>开始设计RESTful API</h2>

<h3>获取所有的tasks</h3>

<p>一个task由id、title、description、done等属性构成，获取task列表的url可以设计成/todo/tasks。具体代码如下，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>
</span><span class='line'>
</span><span class='line'><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;title&#39;</span><span class="p">:</span> <span class="s">u&#39;Buy groceries&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;description&#39;</span><span class="p">:</span> <span class="s">u&#39;Milk, Cheese, Pizza, Fruit, Tylenol&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;done&#39;</span><span class="p">:</span> <span class="bp">False</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;title&#39;</span><span class="p">:</span> <span class="s">u&#39;Learn Python&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;description&#39;</span><span class="p">:</span> <span class="s">u&#39;Need to find a good Python tutorial on the web&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&#39;done&#39;</span><span class="p">:</span> <span class="bp">False</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/todo/tasks&#39;</span><span class="p">,</span> <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">])</span>
</span><span class='line'><span class="k">def</span> <span class="nf">get_tasks</span><span class="p">():</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">jsonify</span><span class="p">({</span><span class="s">&#39;tasks&#39;</span><span class="p">:</span> <span class="n">tasks</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>  <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为Flask运行在debug模式下会自动reload，所以代码写完后保存文件即可。</p>

<p>Mac上有一款名为<a href="https://itunes.apple.com/app/id584653203?ls=1&amp;mt=12">Paw</a>的HTTP Client，算是我见过、用过的各种API测试工具中的佼佼者，力荐。</p>

<p>打开Paw，在url里输入<a href="http://localhost:5000/todo/tasks%EF%BC%8C%E9%80%89%E6%8B%A9GET%EF%BC%8C%E6%95%B2CMD+Enter%E5%8D%B3%E5%8F%AF%E5%90%AC%E5%88%B0%E8%A1%A8%E7%A4%BA%E6%88%90%E5%8A%9F%E7%9A%84%E6%B8%85%E8%84%86%E6%8F%90%E7%A4%BA%E9%9F%B3%E3%80%82Paw%E9%99%A4%E4%BA%86%E6%8F%90%E4%BE%9B%E5%8E%9F%E7%94%9F%E7%9A%84HTTP%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%8F%90%E4%BE%9B%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E6%B5%8F%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%80%89%E6%8B%A9JSON%E6%A0%BC%E5%BC%8F%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost:5000/todo/tasks%EF%BC%8C%E9%80%89%E6%8B%A9GET%EF%BC%8C%E6%95%B2CMD+Enter%E5%8D%B3%E5%8F%AF%E5%90%AC%E5%88%B0%E8%A1%A8%E7%A4%BA%E6%88%90%E5%8A%9F%E7%9A%84%E6%B8%85%E8%84%86%E6%8F%90%E7%A4%BA%E9%9F%B3%E3%80%82Paw%E9%99%A4%E4%BA%86%E6%8F%90%E4%BE%9B%E5%8E%9F%E7%94%9F%E7%9A%84HTTP%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%8F%90%E4%BE%9B%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E6%B5%8F%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%80%89%E6%8B%A9JSON%E6%A0%BC%E5%BC%8F%E5%8D%B3%E5%8F%AF%E3%80%82</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BNR出品的Obj-C教程]]></title>
    <link href="http://balloonsys.github.io/blog/2014/03/05/obj-c-programming/"/>
    <updated>2014-03-05T21:22:44+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/03/05/obj-c-programming</id>
    <content type="html"><![CDATA[<p>据说The Big Nerd Ranch Guide系列教程都很不错，于是到<a href="http://www.ppurl.com/2013/11/objective-c-programming-the-big-nerd-ranch-guide-second-edition-epub.html">皮皮书屋</a>下载了一份BNR出品的关于Obj-C的电子书。在iPad、Mac上阅读ePub格式的文档，有着很不错的体验。</p>

<!--more-->


<p>直接在电子书里记笔记的习惯还没有养成，依旧习惯于在<a href="http://www.iawriter.com/mac/">iA Writer</a>里记录一些知识点以备日后查看。</p>

<ol>
<li>在C的函数里使用BOOL类型，需要#include &lt;objc/objc.h></li>
<li>sleep函数是在unistd.h头文件中声明的</li>
<li>EXIT_SUCCESS等程序退出标志，是在stdlib.h中声明的</li>
<li>全局变量可以在多个文件中访问到；静态变量仅当前文件可以访问</li>
<li>NSInteger在32位系统上占32位，在64位系统上占64位</li>
<li>在格式化输出NSInteger时，需强类型转换成long，然后用%ld打印</li>
<li>求绝对值可以用stdlib.h中的abs()函数</li>
<li>使用readline函数，需要链接libreadline，然后导入主头文件</li>
<li>字符串转数字可以用stdlib.h中的atoi()函数</li>
<li>sizeof()返回size_t类型的数据，可以用%zu格式化输出</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动应用的Freemium模式]]></title>
    <link href="http://balloonsys.github.io/blog/2014/03/01/in-app-purchasing-a-freemium-model/"/>
    <updated>2014-03-01T20:12:22+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/03/01/in-app-purchasing-a-freemium-model</id>
    <content type="html"><![CDATA[<p>In-App Purchasing是一种目前比较常见的定价策略。软件可以免费安装并使用，但如果需要更多或更高级的功能则需要付费，即<a href="http://en.wikipedia.org/wiki/Freemium">Freemium</a>模式。</p>

<!--more-->


<p>昨天给APP集成了<a href="http://balloonsys.com/blog/2014/02/28/make-money-from-ad/">广告服务</a>。碰到有洁癖的用户，被抱怨是免不了的。所以今天抓紧学习IAP相关的开发技术后，又马不停蹄的增加了付费去广告的功能。</p>

<h2>创建IAP商品</h2>

<p>用户只需为“去除广告”这个服务付费一次，并可永久性的免除广告的烦扰。所以这种情况下，“去除广告”应被看成Non-Consumable商品。而游戏中常见的“金币”是用完还需重新购买，属于快速消耗品，对应iTunes Connect后台里的Consumable商品。</p>

<p>商品的ID可采用APP_ID.PRODUCT_NAME的格式，该ID将在编码时用到。</p>

<p>注意创建IAP商品时遇到的Hosting Content with Apple这一项，此处选择No。关于这个Hosting Content的用法，可以参考这篇<a href="http://www.techotopia.com/index.php/Configuring_and_Creating_App_Store_Hosted_Content_for_iOS_6_In-App_Purchases">文章</a>。</p>

<p>添加好名为“remove_ads”的商品后，该IAP的状态为“Ready to Submit”。同时系统提示我说“你的首个IAP必须与新版APP一起提交，请在Version Detail页面选中相关的IAP后点击准备上传按钮”。</p>

<p>收到这样的提示，略有惊喜。因为添加IAP时，该APP有个update还在等待review，而IAP是下个release的内容，当时有点担心此次的操作会影响等待审核的版本。结果证明担心是多余的。</p>

<h2>设置工程</h2>

<p>在构建目标的Capabilities页面，开启In-App Purchase功能。Xcode会自动为当前的App ID增加相关权限，同时链接StoreKit框架。</p>

<p>IAP所涉及到的交互流程主要有如下几步，<br/>
1. APP首先向苹果服务器发起请求（含有商品ID集合）以获得商品信息<br/>
2. 客户端以自定义的方式展示返回的商品<br/>
3. 用户选中某个商品，触发支付请求，请求被加到支付队列<br/>
4. 支付被苹果处理后，会发出Transaction Updated事件<br/>
5. 客户端设置的交易监听者根据Transaction的状态执行不同逻辑</p>

<p>收到Transaction Updated事件后，无论Transaction的状态是completed、failed还是restore，都需要调用finishTransaction以通知苹果服务器相关的通知已收到，否则会不停的收到Transaction Updated事件。</p>

<h2>开始编码</h2>

<h3>请求商品信息</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">productsRequest</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SKProductsRequest</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithProductIdentifiers:</span><span class="n">self</span><span class="p">.</span><span class="n">productIdentifiers</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">productsRequest</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">productsRequest</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当苹果服务器做出“成功”的响应时，会调用SKProductsRequestDelegate方法，从response里我们可以拿到products信息。</p>

<h3>展示返回的商品</h3>

<p>目前采用的是在“关于”页面，放一个静态的table view cell，用户点击后该cell后弹出ActionSheet，让用户选择是首次“购买”还是“恢复”曾经的交易。</p>

<p>看似这个过程和上一步无关，这是因为此处只关心一个“Remove Ads”商品，也不需要显示服务端设定的商品价格等信息。其实此处ActionSheet所显示的选项内容，完全可以由之前获得的product信息构成。</p>

<h3>选中商品，触发支付请求</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">SKPayment</span> <span class="o">*</span><span class="n">payment</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKPayment</span> <span class="nl">paymentWithProduct:</span><span class="n">product</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">SKPaymentQueue</span> <span class="n">defaultQueue</span><span class="p">]</span> <span class="nl">addPayment:</span><span class="n">payment</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>支付请求仅需被加到支付队列即可，StoreKit会完成剩余的工作。当交易的状态发生变化时，客户端APP会收到Transaction Updated事件。</p>

<h3>监听交易状态变化</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">paymentQueue:</span><span class="p">(</span><span class="n">SKPaymentQueue</span> <span class="o">*</span><span class="p">)</span><span class="nv">queue</span> <span class="nf">updatedTransactions:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">transactions</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">SKPaymentTransaction</span> <span class="o">*</span><span class="n">transaction</span> <span class="k">in</span> <span class="n">transactions</span><span class="p">){</span>
</span><span class='line'>      <span class="k">switch</span> <span class="p">(</span><span class="n">transaction</span><span class="p">.</span><span class="n">transactionState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SKPaymentTransactionStatePurchased:</span>
</span><span class='line'>              <span class="p">[</span><span class="n">self</span> <span class="nl">completeTransaction:</span><span class="n">transaction</span><span class="p">];</span>
</span><span class='line'>              <span class="k">break</span><span class="p">;</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SKPaymentTransactionStateFailed:</span>
</span><span class='line'>              <span class="p">[</span><span class="n">self</span> <span class="nl">failedTransaction:</span><span class="n">transaction</span><span class="p">];</span>
</span><span class='line'>              <span class="k">break</span><span class="p">;</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SKPaymentTransactionStateRestored:</span>
</span><span class='line'>              <span class="p">[</span><span class="n">self</span> <span class="nl">restoreTransaction:</span><span class="n">transaction</span><span class="p">];</span>
</span><span class='line'>              <span class="k">break</span><span class="p">;</span>
</span><span class='line'>          <span class="k">default</span><span class="o">:</span>
</span><span class='line'>              <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>处理商品交易</h3>

<p>上面用到的completeTransaction等方法，一方面根据“交易”的状态去设置User Defaults中对应商品的状态（是否已购买）；另一方面调用finishTransaction以通知苹果服务器相关的通知已收到。</p>

<p>示例代码如下，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">completeTransaction:</span><span class="p">(</span><span class="n">SKPaymentTransaction</span> <span class="o">*</span><span class="p">)</span><span class="nv">transaction</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Cache purchased product.</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">purchasedProductIdentifiers</span> <span class="nl">addObject:</span><span class="n">productIdentifier</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Persist purchased product.</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setBool:</span><span class="n">YES</span> <span class="nl">forKey:</span><span class="n">productIdentifier</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="n">synchronize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Notify product purchased, so then UI can be updated accordingly</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">postNotificationName:</span><span class="n">ProductPurchasedNotification</span> <span class="nl">object:</span><span class="n">productIdentifier</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Removes transaction from the queue.</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">SKPaymentQueue</span> <span class="n">defaultQueue</span><span class="p">]</span> <span class="nl">finishTransaction:</span><span class="n">transaction</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中ProductPurchasedNotification是一个自定义消息，收到该消息的控制器并可以做出适当的响应，比如隐藏掉购买按钮or修改按钮的文字or弹框提示用户“购买成功”&hellip;</p>

<h2>问题分析</h2>

<p>从打算加入一个IAP到跑通代码所需要的“必要劳动时间”，远超最初的估计。期间可能遇到的各种错误及相应地应对建议，可以参考<a href="http://www.weibo.com/onevcat">OneV&rsquo;s Den</a>的<a href="http://onevcat.com/2013/11/ios-iap-checklist/">文章</a>。</p>

<h2>功能测试</h2>

<p>IAP的测试，需要在iTunes Connect后台建立一个测试账号。从网络上获得的一点建议：使用之前最好退出平常使用的正式账号，另外也不要用测试账号去下载APP。原因不详，也不想以身试法，遵守就是了！</p>

<h2>参考资料</h2>

<p>如果想系统并深入的学习IAP的开发技术，可以阅读下列文章，  <br/>
1. <a href="http://www.raywenderlich.com/u/rwenderlich">Ray Wenderlich</a>提供的<a href="http://www.raywenderlich.com/21081/introduction-to-in-app-purchases-in-ios-6-tutorial">IAP入门教程</a><br/>
2. <a href="http://www.raywenderlich.com/u/rwenderlich">Ray Wenderlich</a>提供的<a href="http://www.raywenderlich.com/23266/in-app-purchases-in-ios-6-tutorial-consumables-and-receipt-validation">IAP进阶教程</a><br/>
3. 苹果官方提供的开发<a href="https://developer.apple.com/in-app-purchase/">文档</a></p>

<p>如果你需要快速了解IAP的话，不妨读读<a href="http://brianflove.com/author/blove/">Brian Love</a>的这篇<a href="http://brianflove.com/2013/02/11/in-app-purchasing-in-ios-6/">文章</a>。
如果你需要快速实现IAP的话，不妨试试<a href="http://mattt.me">Mattt Thompson</a>的开源库<a href="https://github.com/mattt/CargoBay">CargoBay</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为应用添加广告支持]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/28/make-money-from-ad/"/>
    <updated>2014-02-28T16:22:38+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/28/make-money-from-ad</id>
    <content type="html"><![CDATA[<p>年前做的一款关于公共自行车租赁的APP，自我感觉还是比较实用的。为了造福杭城更多的iPhone用户，新版本打算采用免费+iAP（去广告）的方式发行。所以，今天便研究了下iAd及AdMob两种广告平台的集成方法。</p>

<!--more-->


<h2>AdMob</h2>

<p>想要支持AdMob，需要首先注册账号，添加应用，然后便可获得Publisher ID。至于如何配置工程以支持AdMob，可以参考<a href="https://developers.google.com/mobile-ads-sdk/docs/#ios">这里</a>。</p>

<h2>iAd &amp; AdMob</h2>

<p>如果是手动编写代码以同时支持iAd和AdMob可参考<a href="http://www.apptite.be/tutorial_mixing_ads.php">这里</a>。另外Github上有一个开源库<a href="https://github.com/larsacus/LARSAdController">LARSAdController</a>，使用起来非常方便。</p>

<h2>收益</h2>

<p>集成AdMob的版本尚未上架，自己在手机上对着开发者证书安装的APP里的广告变着法子点击（换不同的VPN服务器、重置IDFA），竟然也能收获三十来刀。但这是冒着被封号的危险，谨慎啊！</p>

<p>这里有篇关于AdMob的<a href="http://blog.sina.com.cn/s/blog_7193dd920101keay.html">经验贴</a>，很有料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与Auto Layout相关的各种知识点]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/27/hacking-auto-layout/"/>
    <updated>2014-02-27T15:17:15+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/27/hacking-auto-layout</id>
    <content type="html"><![CDATA[<p>Auto Layout不光为设计不同尺寸的界面带来了便利，在应用的多语言支持方面也有广泛使用。</p>

<p>继续看书</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于View的用法简介]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/25/introduction-about-view/"/>
    <updated>2014-02-25T15:50:00+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/25/introduction-about-view</id>
    <content type="html"><![CDATA[<p>本文主要针对iOS的视图相关的用法作一些介绍。</p>

<!--more-->


<h2>The Window</h2>

<p>当应用启动时，UIApplicationMain会创建一个appDelegate实例。App Delegate会“持有”一个window实例（strong型）。所以window对象的生命周期与应用一致。</p>

<p>获得window实例有三种方式：<br/>
1. view.window<br/>
2. [UIApplication sharedApplication].delegate.window <br/>
3. [UIApplication sharedApplication].keyWindow</p>

<p>需要注意的是keyWindow有可能发生变化，比如当显示UIAlertView时，keyWindow为该弹出框！</p>

<h2>Subview and Superview</h2>

<p>关于父子视图间的常见操作主要有：<br/>
1. 限制子视图只在父视图区域内绘制，可设置父视图的clipsToBounds属性<br/>
2. 判断一个视图是不是另一个的子孙视图，可以用isDescendantOfView:<br/>
3. 子视图从父视图中移除掉，会被“释放”。若后续需使用，可另行“持有”<br/>
4. 与视图结构相关的几个方法：<br/>
insertSubview:atIndex:<br/>
insertSubview:belowSubview:<br/>
exchangeSubviewAtIndex:withSubviewAtIndex:<br/>
bringSubviewToFront:<br/>
5. 将父视图的所有子视图移除掉，可以用下面这种写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">view</span><span class="p">.</span><span class="n">subviews</span> <span class="nl">makeObjectPerformSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">removeFromSuperView</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Visibility and Opacity</h2>

<p>Alpha，可理解为相对于父视图的不透明度。所以即使一个视图的alpha值为1，它也有可能是透明的。</p>

<p>Opaque，不是用来影响视图的显示，而是用于绘图系统的一个hint值，以便绘制更加高效。</p>

<h2>Bounds, Center and Frame</h2>

<p>Bounds代表的是视图自身的坐标系，而frame表示的是该视图在父视图中的位置。</p>

<p>改变bounds的宽高，会影响其frame，保持不变的是center值。改变bounds的origin值，相当于说该视图坐标系左上角那个点的值被改变，因此其坐标系的原点移到其他位置了。而子视图是在父视图的坐标系里定位的，所以子视图会因父视图的origin变化而逆向变化。</p>

<p>Center是视图bounds的中心点在父视图中的位置。Center加bounds相当于frame。</p>

<p>假如v2是v1的子视图，要想把v2放在v1的中心，可以这么做，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">v2</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span> <span class="nl">convertPoint:</span><span class="n">v1</span><span class="p">.</span><span class="n">center</span> <span class="nl">fromView:</span><span class="n">v1</span><span class="p">.</span><span class="n">superview</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Transform</h2>

<p>将视图v顺时针旋转45°，可以设置其transform属性为CGAffineTransformMakeRotation(45*M_PI/180.0)。此时v的frame是旋转后的v的外接矩形。其子视图虽然也跟着旋转，但子视图的frame并无变化，因为v的bounds不变（即v自身的坐标系不变）。</p>

<p>拉伸函数CGAffineTransformMakeScale会使得视图的frame发生变化，但其bounds保持不变。子视图的frame、bounds、center值均保持不变。</p>

<p>组合若干变换应用到视图上，下面代码先将v旋转，然后在沿着自身坐标系的x轴方向平移100个点。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeRotation</span><span class="p">(</span><span class="mi">45</span> <span class="o">*</span> <span class="n">M_PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformTranslate</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">transform</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以使用CGAffineTransformConcat组合多个变换，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGAffineTransform</span> <span class="n">r</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeRotation</span><span class="p">(</span><span class="mi">45</span> <span class="o">*</span> <span class="n">M_PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">);</span>
</span><span class='line'><span class="n">CGAffineTransform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformConcat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">r</span><span class="p">);</span> <span class="c1">// not r,t</span>
</span></code></pre></td></tr></table></div></figure>


<p>撤销组合变换中的某个变换，只需再次叠加其反变换。比如需要将v在新位置逆时针旋转45°，只需执行下面这行代码，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformConcat</span><span class="p">(</span><span class="n">CGAffineTransformInvert</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">transform</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Layout</h2>

<p>布局除了手动设置布局以及Autoresizing之外，还有自iOS 6引入的Auto-layout。</p>

<p>Autoresizing发生在layoutSubviews执行之前，所以手动设置布局可放在layoutSubviews方法中。自定义的view，如果需要支持Auto-layout，需要在requiresConstraintBasedLayout返回YES。</p>

<p>关于Auto-layout的内容比较多，另行总结！</p>
]]></content>
  </entry>
  
</feed>
