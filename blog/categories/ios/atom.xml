<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Balloonsys Inc.]]></title>
  <link href="http://balloonsys.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://balloonsys.github.io/"/>
  <updated>2014-03-11T19:55:24+08:00</updated>
  <id>http://balloonsys.github.io/</id>
  <author>
    <name><![CDATA[Linkou Bian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[移动应用的Freemium模式]]></title>
    <link href="http://balloonsys.github.io/blog/2014/03/01/in-app-purchasing-a-freemium-model/"/>
    <updated>2014-03-01T20:12:22+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/03/01/in-app-purchasing-a-freemium-model</id>
    <content type="html"><![CDATA[<p>In-App Purchasing是一种目前比较常见的定价策略。软件可以免费安装并使用，但如果需要更多或更高级的功能则需要付费，即<a href="http://en.wikipedia.org/wiki/Freemium">Freemium</a>模式。</p>

<!--more-->


<p>昨天给APP集成了<a href="http://balloonsys.com/blog/2014/02/28/make-money-from-ad/">广告服务</a>。碰到有洁癖的用户，被抱怨是免不了的。所以今天抓紧学习IAP相关的开发技术后，又马不停蹄的增加了付费去广告的功能。</p>

<h2>创建IAP商品</h2>

<p>用户只需为“去除广告”这个服务付费一次，并可永久性的免除广告的烦扰。所以这种情况下，“去除广告”应被看成Non-Consumable商品。而游戏中常见的“金币”是用完还需重新购买，属于快速消耗品，对应iTunes Connect后台里的Consumable商品。</p>

<p>商品的ID可采用APP_ID.PRODUCT_NAME的格式，该ID将在编码时用到。</p>

<p>注意创建IAP商品时遇到的Hosting Content with Apple这一项，此处选择No。关于这个Hosting Content的用法，可以参考这篇<a href="http://www.techotopia.com/index.php/Configuring_and_Creating_App_Store_Hosted_Content_for_iOS_6_In-App_Purchases">文章</a>。</p>

<p>添加好名为“remove_ads”的商品后，该IAP的状态为“Ready to Submit”。同时系统提示我说“你的首个IAP必须与新版APP一起提交，请在Version Detail页面选中相关的IAP后点击准备上传按钮”。</p>

<p>收到这样的提示，略有惊喜。因为添加IAP时，该APP有个update还在等待review，而IAP是下个release的内容，当时有点担心此次的操作会影响等待审核的版本。结果证明担心是多余的。</p>

<h2>设置工程</h2>

<p>在构建目标的Capabilities页面，开启In-App Purchase功能。Xcode会自动为当前的App ID增加相关权限，同时链接StoreKit框架。</p>

<p>IAP所涉及到的交互流程主要有如下几步，<br/>
1. APP首先向苹果服务器发起请求（含有商品ID集合）以获得商品信息<br/>
2. 客户端以自定义的方式展示返回的商品<br/>
3. 用户选中某个商品，触发支付请求，请求被加到支付队列<br/>
4. 支付被苹果处理后，会发出Transaction Updated事件<br/>
5. 客户端设置的交易监听者根据Transaction的状态执行不同逻辑</p>

<p>收到Transaction Updated事件后，无论Transaction的状态是completed、failed还是restore，都需要调用finishTransaction以通知苹果服务器相关的通知已收到，否则会不停的收到Transaction Updated事件。</p>

<h2>开始编码</h2>

<h3>请求商品信息</h3>

<p>``` objc</p>

<pre><code>self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:self.productIdentifiers];
self.productsRequest.delegate = self;
[self.productsRequest start];
</code></pre>

<p>```</p>

<p>当苹果服务器做出“成功”的响应时，会调用SKProductsRequestDelegate方法，从response里我们可以拿到products信息。</p>

<h3>展示返回的商品</h3>

<p>目前采用的是在“关于”页面，放一个静态的table view cell，用户点击后该cell后弹出ActionSheet，让用户选择是首次“购买”还是“恢复”曾经的交易。</p>

<p>看似这个过程和上一步无关，这是因为此处只关心一个“Remove Ads”商品，也不需要显示服务端设定的商品价格等信息。其实此处ActionSheet所显示的选项内容，完全可以由之前获得的product信息构成。</p>

<h3>选中商品，触发支付请求</h3>

<p>``` objc</p>

<pre><code>SKPayment *payment = [SKPayment paymentWithProduct:product];
[[SKPaymentQueue defaultQueue] addPayment:payment];
</code></pre>

<p>```</p>

<p>支付请求仅需被加到支付队列即可，StoreKit会完成剩余的工作。当交易的状态发生变化时，客户端APP会收到Transaction Updated事件。</p>

<h3>监听交易状态变化</h3>

<p>``` objc
&ndash; (void)paymentQueue:(SKPaymentQueue <em>)queue updatedTransactions:(NSArray </em>)transactions
{</p>

<pre><code>for (SKPaymentTransaction *transaction in transactions){
    switch (transaction.transactionState) {
        case SKPaymentTransactionStatePurchased:
            [self completeTransaction:transaction];
            break;
        case SKPaymentTransactionStateFailed:
            [self failedTransaction:transaction];
            break;
        case SKPaymentTransactionStateRestored:
            [self restoreTransaction:transaction];
            break;
        default:
            break;
    }
}
</code></pre>

<p>}
```</p>

<h3>处理商品交易</h3>

<p>上面用到的completeTransaction等方法，一方面根据“交易”的状态去设置User Defaults中对应商品的状态（是否已购买）；另一方面调用finishTransaction以通知苹果服务器相关的通知已收到。</p>

<p>示例代码如下，
``` objc
&ndash; (void)completeTransaction:(SKPaymentTransaction *)transaction
{</p>

<pre><code>// Cache purchased product.
[self.purchasedProductIdentifiers addObject:productIdentifier];

// Persist purchased product.
[[NSUserDefaults standardUserDefaults] setBool:YES forKey:productIdentifier];
[[NSUserDefaults standardUserDefaults] synchronize];

// Notify product purchased, so then UI can be updated accordingly
[[NSNotificationCenter defaultCenter] postNotificationName:ProductPurchasedNotification object:productIdentifier];

// Removes transaction from the queue.
[[SKPaymentQueue defaultQueue] finishTransaction:transaction];
</code></pre>

<p>}
```</p>

<p>其中ProductPurchasedNotification是一个自定义消息，收到该消息的控制器并可以做出适当的响应，比如隐藏掉购买按钮or修改按钮的文字or弹框提示用户“购买成功”&hellip;</p>

<h2>问题分析</h2>

<p>从打算加入一个IAP到跑通代码所需要的“必要劳动时间”，远超最初的估计。期间可能遇到的各种错误及相应地应对建议，可以参考<a href="http://www.weibo.com/onevcat">OneV&rsquo;s Den</a>的<a href="http://onevcat.com/2013/11/ios-iap-checklist/">文章</a>。</p>

<h2>功能测试</h2>

<p>IAP的测试，需要在iTunes Connect后台建立一个测试账号。从网络上获得的一点建议：使用之前最好退出平常使用的正式账号，另外也不要用测试账号去下载APP。原因不详，也不想以身试法，遵守就是了！</p>

<h2>参考资料</h2>

<p>如果想系统并深入的学习IAP的开发技术，可以阅读下列文章，  <br/>
1. <a href="http://www.raywenderlich.com/u/rwenderlich">Ray Wenderlich</a>提供的<a href="http://www.raywenderlich.com/21081/introduction-to-in-app-purchases-in-ios-6-tutorial">IAP入门教程</a><br/>
2. <a href="http://www.raywenderlich.com/u/rwenderlich">Ray Wenderlich</a>提供的<a href="http://www.raywenderlich.com/23266/in-app-purchases-in-ios-6-tutorial-consumables-and-receipt-validation">IAP进阶教程</a><br/>
3. 苹果官方提供的开发<a href="https://developer.apple.com/in-app-purchase/">文档</a></p>

<p>如果你需要快速了解IAP的话，不妨读读<a href="http://brianflove.com/author/blove/">Brian Love</a>的这篇<a href="http://brianflove.com/2013/02/11/in-app-purchasing-in-ios-6/">文章</a>。
如果你需要快速实现IAP的话，不妨试试<a href="http://mattt.me">Mattt Thompson</a>的开源库<a href="https://github.com/mattt/CargoBay">CargoBay</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为应用添加广告支持]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/28/make-money-from-ad/"/>
    <updated>2014-02-28T16:22:38+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/28/make-money-from-ad</id>
    <content type="html"><![CDATA[<p>年前做的一款关于公共自行车租赁的APP，自我感觉还是比较实用的。为了造福杭城更多的iPhone用户，新版本打算采用免费+iAP（去广告）的方式发行。所以，今天便研究了下iAd及AdMob两种广告平台的集成方法。</p>

<!--more-->


<h2>AdMob</h2>

<p>想要支持AdMob，需要首先注册账号，添加应用，然后便可获得Publisher ID。至于如何配置工程以支持AdMob，可以参考<a href="https://developers.google.com/mobile-ads-sdk/docs/#ios">这里</a>。</p>

<h2>iAd &amp; AdMob</h2>

<p>如果是手动编写代码以同时支持iAd和AdMob可参考<a href="http://www.apptite.be/tutorial_mixing_ads.php">这里</a>。另外Github上有一个开源库<a href="https://github.com/larsacus/LARSAdController">LARSAdController</a>，使用起来非常方便。</p>

<h2>收益</h2>

<p>集成AdMob的版本尚未上架，自己在手机上对着开发者证书安装的APP里的广告变着法子点击（换不同的VPN服务器、重置IDFA），竟然也能收获三十来刀。但这是冒着被封号的危险，谨慎啊！</p>

<p>这里有篇关于AdMob的<a href="http://blog.sina.com.cn/s/blog_7193dd920101keay.html">经验贴</a>，很有料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与Auto Layout相关的各种知识点]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/27/hacking-auto-layout/"/>
    <updated>2014-02-27T15:17:15+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/27/hacking-auto-layout</id>
    <content type="html"><![CDATA[<p>Auto Layout不光为设计不同尺寸的界面带来了便利，在应用的多语言支持方面也有广泛使用。</p>

<p>继续看书</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于View的用法简介]]></title>
    <link href="http://balloonsys.github.io/blog/2014/02/25/introduction-about-view/"/>
    <updated>2014-02-25T15:50:00+08:00</updated>
    <id>http://balloonsys.github.io/blog/2014/02/25/introduction-about-view</id>
    <content type="html"><![CDATA[<p>本文主要针对iOS的视图相关的用法作一些介绍。</p>

<!--more-->


<h2>The Window</h2>

<p>当应用启动时，UIApplicationMain会创建一个appDelegate实例。App Delegate会“持有”一个window实例（strong型）。所以window对象的生命周期与应用一致。</p>

<p>获得window实例有三种方式：<br/>
1. view.window<br/>
2. [UIApplication sharedApplication].delegate.window <br/>
3. [UIApplication sharedApplication].keyWindow</p>

<p>需要注意的是keyWindow有可能发生变化，比如当显示UIAlertView时，keyWindow为该弹出框！</p>

<h2>Subview and Superview</h2>

<p>关于父子视图间的常见操作主要有：<br/>
1. 限制子视图只在父视图区域内绘制，可设置父视图的clipsToBounds属性<br/>
2. 判断一个视图是不是另一个的子孙视图，可以用isDescendantOfView:<br/>
3. 子视图从父视图中移除掉，会被“释放”。若后续需使用，可另行“持有”<br/>
4. 与视图结构相关的几个方法：<br/>
insertSubview:atIndex:<br/>
insertSubview:belowSubview:<br/>
exchangeSubviewAtIndex:withSubviewAtIndex:<br/>
bringSubviewToFront:<br/>
5. 将父视图的所有子视图移除掉，可以用下面这种写法：<br/>
<code>objc
[view.subviews makeObjectPerformSelector:@selector(removeFromSuperView)];
</code></p>

<h2>Visibility and Opacity</h2>

<p>Alpha，可理解为相对于父视图的不透明度。所以即使一个视图的alpha值为1，它也有可能是透明的。</p>

<p>Opaque，不是用来影响视图的显示，而是用于绘图系统的一个hint值，以便绘制更加高效。</p>

<h2>Bounds, Center and Frame</h2>

<p>Bounds代表的是视图自身的坐标系，而frame表示的是该视图在父视图中的位置。</p>

<p>改变bounds的宽高，会影响其frame，保持不变的是center值。改变bounds的origin值，相当于说该视图坐标系左上角那个点的值被改变，因此其坐标系的原点移到其他位置了。而子视图是在父视图的坐标系里定位的，所以子视图会因父视图的origin变化而逆向变化。</p>

<p>Center是视图bounds的中心点在父视图中的位置。Center加bounds相当于frame。</p>

<p>假如v2是v1的子视图，要想把v2放在v1的中心，可以这么做，
<code>objc
v2.center = [v1 convertPoint:v1.center fromView:v1.superview];
</code></p>

<h2>Transform</h2>

<p>将视图v顺时针旋转45°，可以设置其transform属性为CGAffineTransformMakeRotation(45*M_PI/180.0)。此时v的frame是旋转后的v的外接矩形。其子视图虽然也跟着旋转，但子视图的frame并无变化，因为v的bounds不变（即v自身的坐标系不变）。</p>

<p>拉伸函数CGAffineTransformMakeScale会使得视图的frame发生变化，但其bounds保持不变。子视图的frame、bounds、center值均保持不变。</p>

<p>组合若干变换应用到视图上，下面代码先将v旋转，然后在沿着自身坐标系的x轴方向平移100个点。
<code>objc
v.transform = CGAffineTransformMakeRotation(45 * M_PI/180.0);
v.transform = CGAffineTransformTranslate(v2.transform, 100, 0);
</code></p>

<p>也可以使用CGAffineTransformConcat组合多个变换，
<code>objc
CGAffineTransform r = CGAffineTransformMakeRotation(45 * M_PI/180.0);
CGAffineTransform t = CGAffineTransformMakeTranslation(100, 0);
v.transform = CGAffineTransformConcat(t,r); // not r,t
</code></p>

<p>撤销组合变换中的某个变换，只需再次叠加其反变换。比如需要将v在新位置逆时针旋转45°，只需执行下面这行代码，
<code>objc
v.transform = CGAffineTransformConcat(CGAffineTransformInvert(r), v.transform);
</code></p>

<h2>Layout</h2>

<p>布局除了手动设置布局以及Autoresizing之外，还有自iOS 6引入的Auto-layout。</p>

<p>Autoresizing发生在layoutSubviews执行之前，所以手动设置布局可放在layoutSubviews方法中。自定义的view，如果需要支持Auto-layout，需要在requiresConstraintBasedLayout返回YES。</p>

<p>关于Auto-layout的内容比较多，另行总结！</p>
]]></content>
  </entry>
  
</feed>
