<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Navigation | Balloonsys Inc.]]></title>
  <link href="http://balloonsys.github.io/blog/categories/navigation/atom.xml" rel="self"/>
  <link href="http://balloonsys.github.io/"/>
  <updated>2015-07-04T23:34:34+08:00</updated>
  <id>http://balloonsys.github.io/</id>
  <author>
    <name><![CDATA[Linkou Bian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Avoid Nested Push Animation]]></title>
    <link href="http://balloonsys.github.io/blog/2015/07/04/avoid-nested-push-animation/"/>
    <updated>2015-07-04T21:28:39+08:00</updated>
    <id>http://balloonsys.github.io/blog/2015/07/04/avoid-nested-push-animation</id>
    <content type="html"><![CDATA[<p>在iOS 8里使用UINavigationController把一个页面Push出来后，很短的时间内再次Push一个页面，并没有太大问题，两个页面相继显示。但在iOS 7里运行会遇到nested push animation can result in corrupted navigation bar问题。</p>

<!--more-->


<h2>模拟项目</h2>

<h3>方法一</h3>

<p>给一个按钮添加点击事件，在事件响应里：
``` objc</p>

<pre><code>UIViewController *detailPage = [UIViewController new];
UIViewController *anotherPage = [UIViewController new];

[self.navigationController pushViewController:detailPage animated:YES];

dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.3 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
    [self.navigationController pushViewController:anotherPage animated:YES];
});
</code></pre>

<p>```
这样一点击此按钮，便可模拟本文着重讨论的问题。</p>

<h3>方法二</h3>

<p>实际项目里有两个基于View实现的控件，点击时首先缩放一下控件里的图标，然后push一个页面。当点击控件A后，若快速点击控件B，就会发生nested push问题。</p>

<p>方法二中控件带有一定时长的缩放动画，给了用户足够的反应时间去连续点击。而方法一中是基于GCD代码模拟，可精确控制nested push的间隔。代码在 <a href="https://github.com/balloonsys/PushVC">PushVC示例之Initial Commit</a></p>

<h2>问题剖析</h2>

<p>首先，从UINavigationController这一层面考虑，在第一个push的动画还没完成，到来的第二个push请求，是否可以忽略？印象中貌似iOS 6就是这么处理的。</p>

<p>然后，我们也可以从UI层面控制，尽量不要在push过程中发起第二次push请求。</p>

<h2>解决方案</h2>

<p>UINavigationController在push过程中，如何忽略其他push请求呢？查看其Delegate，发现其中有如下两个方法：
<code>objc
- navigationController:willShowViewController:animated:
- navigationController:didShowViewController:animated:
</code></p>

<p>所以，我们可以基于UINavigationController建立NavController，增加一个名为inTransition的BOOL属性。将NavController的delegate指向自身，并实现上述两个delegate方法。在willShow中将inTransition置为YES，在didShow中置为NO。接下来重写pushViewController:animated方法：
``` objc
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {</p>

<pre><code>if (self.inTransition) {
    NSLog(@“Ignore push request when top page is still animating”);
    return;
}

[super pushViewController:viewController animated:animated];
</code></pre>

<p>}
```</p>

<p>此时运行模拟项目，快速点击两个控件后，控制台会出现“Ignore push request when top page is still animating”消息，说明使用NavController可以像iOS 6的UINavigationController那样成功避免Nested Push问题。</p>

<p>如前分析，我们也可以在UI层做控制，避免在Push过程中发起Push请求。仔细分析一下，第二次Push请求可能在控件的动画过程中发起，也可能在第一次Push过程中发起。所以，控件（示例中是基于View实现的）是否响应事件（示例中是基于tapGesture实现的）需要考虑两个条件。</p>

<h2>前端控制</h2>

<p>如何在动画过程中，避免另一个控件发起Push请求？我们可以在第一个控件的动画过程中，忽略触摸事件即可。核心代码是UIApplication的beginIgnoringInteractionEvents和endIgnoringInteractionEvents方法。主要代码如下：
``` objc
&ndash; (void)tapped {</p>

<pre><code>if (self.iconView) {
    if ([self.iconView.layer animationForKey:TAP_ANIMATION_KEY] == nil) {
        [self.iconView.layer addAnimation:[self tapAnimation] forKey:TAP_ANIMATION_KEY];

        [[UIApplication sharedApplication] beginIgnoringInteractionEvents];
        self.inAnimating = YES;

    } else {
        NSLog(@“Do NOT tap until animation for %@ stopped”, self);
    }
} else {
    [super tapped];
}
</code></pre>

<p>}</p>

<ul>
<li><p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {</p>

<p>  [[UIApplication sharedApplication] endIgnoringInteractionEvents];
  self.inAnimating = NO;</p>

<p>  [super tapped];
}
```</p></li>
</ul>


<p>当然也可以判断是否有其他控件处于inAnimating状态，以决定是否忽略当前控件的触摸事件（gestureRecognizer:shouldReceiveTouch:）。</p>

<p>如何避免在Push过程中再次发送Push请求呢？我们可以在UIGestureRecognizerDelegate方法（方法名前面刚刚提过）中判断：
``` objc
&ndash; (BOOL)gestureRecognizer:(UIGestureRecognizer <em>)recogniser shouldReceiveTouch:(UITouch </em>)touch {</p>

<pre><code>if ([self.navigationController isKindOfClass:[NavController class]]) {
    NavController *nav = (NavController *)self.navigationController;
    return !nav.inTransition;
}

return YES;
</code></pre>

<p>}
```</p>

<p>完整的代码可以从Github获得，(PushVC)[<a href="https://github.com/balloonsys/PushVC">https://github.com/balloonsys/PushVC</a>]。</p>

<h2>参考资料</h2>

<ol>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationControllerDelegate_Protocol/">UINavigationControllerDelegate</a></li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html">Turn off delivery of touch events for a period</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
